import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream

plugins {
    id 'application'
    id "jacoco"
    id "org.sonarqube" version "2.7.1"
}

def config = new ConfigSlurper().parse(new File("$projectDir/src/main/resources/version.properties").toURI().toURL())
group = 'co.rsk'
version = config.modifier?.trim() ? config.versionNumber + "-" + config.modifier : config.versionNumber

test {
    beforeTest { descriptor ->
        logger.lifecycle("Running test: ${descriptor}")
    }

    jvmArgs '-Xss32m', '-Xmx3G'

    testLogging {
        events "failed"
        exceptionFormat "short"
    }
    systemProperty "file.encoding", "UTF-8"
    finalizedBy jacocoTestReport
}

repositories {
    mavenCentral()
    jcenter()
    maven {
        url "https://deps.rsklabs.io"
    }
}

sourceCompatibility = 1.8

mainClassName = 'co.rsk.federate.FederateRunner'
applicationDefaultJvmArgs = ["-server", "-Xss32m", "-Xms3g", "-XX:+UseCompressedOops", "-XX:-OmitStackTraceInFastThrow"]

tasks.withType(JavaCompile){
    options.warnings = false
    options.encoding = 'UTF-8'
    options.compilerArgs << '-XDignore.symbol.file'
}

tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

ext {
    bitcoinjcoreVersion = '0.15.6-rsk-1'
    bitcoinjVersion = '0.14.4-rsk-fb'
    commonsLang3Version = '3.5'
    commonsIoVersion = '2.5'
    slf4jVersion = '1.7.25'
    javaxAnnotationApiVersion = '1.3.2'
    jacksonDatabindVersion = '2.8.7'
    typesafeVersion = '1.3.3'
    logbackVersion = '1.2.2'
    junitVersion = '4.12'
    mockitoVersion = '2.23.4'
    powermockitoVersion = '2.0.2'
    rskjcoreVersion = '2.2.0-SNAPSHOT'
}

dependencies {
    implementation "co.rsk:rskj-core:${rskjcoreVersion}"

    implementation "org.bitcoinj:core:${bitcoinjcoreVersion}"
    implementation "co.rsk.bitcoinj:bitcoinj-thin:${bitcoinjVersion}"
    implementation "org.apache.commons:commons-lang3:${commonsLang3Version}"
    implementation "commons-io:commons-io:${commonsIoVersion}"
    implementation "org.slf4j:slf4j-api:${slf4jVersion}"
    implementation "javax.annotation:javax.annotation-api:${javaxAnnotationApiVersion}"
    implementation "com.fasterxml.jackson.core:jackson-databind:${jacksonDatabindVersion}"
    implementation "com.typesafe:config:${typesafeVersion}"

    testImplementation "junit:junit:${junitVersion}"
    testImplementation "org.mockito:mockito-core:${mockitoVersion}"
    testImplementation "org.powermock:powermock-module-junit4:${powermockitoVersion}"
    testImplementation "org.powermock:powermock-api-mockito2:${powermockitoVersion}"
}

javadoc {
    options.author = true
    options.header = "FedNode"
    options.addStringOption('Xdoclint:none', '-quiet')
    options.encoding = "UTF-8"
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar) {
    classifier = "javadoc"
    from javadoc
}

def generatedResources = "$buildDir/generated-resources"
sourceSets {
    main {
        resources {
            srcDirs += generatedResources
        }
    }
}

task generateResources {
    doLast {
        mkdir generatedResources
        def generated = new File(generatedResources, 'build-info.properties')
        def commitHash = gitCommitHash()
        def currentBranch = gitCurrentBranch()
        generated.text = """
build.hash=$commitHash
build.branch=$currentBranch
"""
    }
}

tasks.withType(Jar) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
    dirMode = 0775
    fileMode = 0664
    doLast {
        stripJar(outputs.files.singleFile)
    }
}

jar {
    def commitHash = gitCommitHash()
    def currentBranch = gitCurrentBranch()
    manifest {
        attributes  'Git-Commit': commitHash,
                    'Git-Branch': currentBranch
    }
    from sourceSets.main.output.classesDirs
    from sourceSets.main.output.resourcesDir
    from generatedResources
}

task fatJar(type: Jar, dependsOn: jar) {
    manifest {
        attributes 'Main-Class': "$mainClassName"
    }
    exclude "META-INF/*.SF", "META-INF/*.DSA", "META-INF/*.RSA"
    classifier = 'all'
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}

artifacts {
    archives sourcesJar
    archives javadocJar
    archives fatJar
}

def gitCurrentBranch() {
    def process = "git rev-parse --abbrev-ref HEAD".execute()
    return process.text.trim()
}

def gitCommitHash() {
    def process = "git rev-parse --short HEAD".execute()
    return process.text.trim()
}

def gitDateHash() {
    def process = "git show -s --format=%ct ${gitCommitHash()}".execute()
    return process.text.toLong()
}

def stripJar(File originalFile) {
    def constantTimeForZipEntries = new GregorianCalendar(1980, Calendar.FEBRUARY, 1, 0, 0, 0).timeInMillis
    def reproducibleFile = File.createTempFile("temp", ".tmp")
    reproducibleFile.withOutputStream { fout ->
        def out = new JarOutputStream(fout)
        def jf = new JarFile(originalFile)
        jf.entries().unique {it.name}.sort {it.name}.each {
            def copy = new JarEntry(it.name)
            copy.time = constantTimeForZipEntries
            out.putNextEntry(copy)
            out << jf.getInputStream(it)
        }
        out.finish()
    }
    reproducibleFile.renameTo originalFile
}
